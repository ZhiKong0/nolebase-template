
# 实现代码
- 动态显示+计时器+多位数码管+缓存显存+中断扫描
```c
#include <STC15F2K60S2.H>
#include <intrins.h>

/* ===================== 硬件锁存器地址 ===================== */
#define LATCH_LED   0x80
#define LATCH_DIG   0xC0
#define LATCH_SEG   0xE0

typedef unsigned char  u8;
typedef unsigned int   u16;

/* ===================== 显示参数 ===================== */
#define DIGITS 8

/* 数码管段码表：0~9（低电平点亮，dp默认灭） */
static const u8 SEG_TAB[10] = {
    0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90
};

/* 位选表：第1~8位 */
static const u8 DIG_TAB[DIGITS] = {
    0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80
};

/* ===================== 系统状态 ===================== */
typedef enum {
    Nixie_State_ScreenOff = 0,
    Nixie_State_Run,
    Nixie_State_Pause
} Nixie_State;

/* ===================== 全局：显示驱动层（显存 + 扫描） ===================== */
static volatile u8  g_dispBuf[DIGITS];     // 显存：每位的段码
static volatile u8  g_scanPos = 0;         // 当前扫描位
static volatile u8  g_ledShadow = 0x00;    // LED影子（可选）
static volatile bit g_tick10ms = 0;        // 10ms节拍
static volatile bit g_tick100ms = 0;       // 100ms节拍

/* ===================== 全局：按键层（简单消抖） ===================== */
static volatile u16 g_keyStable = 0;       // 稳定键值（位图）
static volatile u16 g_keyDown = 0;         // 下降沿（按下事件）

/* ===================== 底层总线写 ===================== */
static void BusWrite(u8 addr, u8 dat)
{
    P0 = dat;
    P2 = addr;
    _nop_();
    P2 = 0x00;
}

/* ===================== 显示API：主循环只用这些 ===================== */
static void SEG_Clear(void)
{
    u8 i;
    for(i = 0; i < DIGITS; i++) g_dispBuf[i] = 0xFF; // 全灭
}

static void SEG_SetDigit(u8 pos, u8 num)
{
    if(pos >= DIGITS) return;
    if(num > 9) num = 0;
    g_dispBuf[pos] = SEG_TAB[num];
}

/* 显示两位十进制：从 pos 开始（pos显示十位，pos+1显示个位） */
static void SEG_Set2Dec(u8 pos, u8 value) // value: 0~99
{
    u8 tens = value / 10;
    u8 ones = value % 10;
    SEG_SetDigit(pos, tens);
    SEG_SetDigit(pos + 1, ones);
}

/* ===================== 按键扫描（矩阵映射为16位位图） ===================== */
/* 你原来的矩阵映射逻辑：每个键对应 bit0~bit15 */
static u16 Key_ScanMap(void)
{
    u16 map = 0;
    u8 row;

    /* 列输入上拉 */
    P44 = 1; P42 = 1; P35 = 1; P34 = 1;

    for(row = 0; row < 4; row++)
    {
        /* 行输出先全1，再拉低某一行 */
        P30 = 1; P31 = 1; P32 = 1; P33 = 1;
        if(row == 0) P30 = 0;
        else if(row == 1) P31 = 0;
        else if(row == 2) P32 = 0;
        else P33 = 0;

        if(!P44) map |= (1u << (row * 4 + 0));
        if(!P42) map |= (1u << (row * 4 + 1));
        if(!P35) map |= (1u << (row * 4 + 2));
        if(!P34) map |= (1u << (row * 4 + 3));
    }

    return map;
}

/* 取“按下事件”：index 1~16 */
static bit Key_GetDown(u8 index)
{
    if(index < 1 || index > 16) return 0;
    return (g_keyDown & (1u << (index - 1))) ? 1 : 0;
}

/* ===================== 定时器0：0.5ms 中断（11.0592MHz，12T） ===================== */
static void Timer0_Init_0p5ms(void)
{
    AUXR &= ~0x80;   // 12T
    TMOD &= 0xF0;
    TMOD |= 0x01;    // mode1 16-bit
    TH0 = 0xFE;
    TL0 = 0x33;
    ET0 = 1;
    EA  = 1;
    TR0 = 1;
}

/* ===================== 中断：扫描显示 + 产生节拍 + 按键消抖 ===================== */
void Timer0_ISR(void) interrupt 1
{
    static u8  cnt10ms = 0;      // 0.5ms * 20 = 10ms
    static u8  cnt100ms = 0;     // 10ms * 10 = 100ms
    static u16 key_last = 0;
    static u8  key_same_cnt = 0; // 连续相同计数（消抖）

    /* 重装载 */
    TH0 = 0xFE;
    TL0 = 0x33;

    /* ------- A) 动态扫描 1 位（工业标准三步：消隐->选位->出段码） ------- */
    BusWrite(LATCH_SEG, 0xFF);                   // 消隐
    BusWrite(LATCH_DIG, DIG_TAB[g_scanPos]);     // 选位
    BusWrite(LATCH_SEG, g_dispBuf[g_scanPos]);   // 出段码

    g_scanPos++;
    if(g_scanPos >= DIGITS) g_scanPos = 0;

    /* ------- B) 10ms/100ms 节拍 ------- */
    if(++cnt10ms >= 20) // 10ms
    {
        cnt10ms = 0;
        g_tick10ms = 1;

        if(++cnt100ms >= 10) // 100ms
        {
            cnt100ms = 0;
            g_tick100ms = 1;
        }

        /* ------- C) 按键消抖：10ms采样，连续2次相同才认为稳定（约20ms） ------- */
        {
            u16 now = Key_ScanMap();
            if(now == key_last)
            {
                if(key_same_cnt < 2) key_same_cnt++;
            }
            else
            {
                key_same_cnt = 0;
                key_last = now;
            }

            if(key_same_cnt == 2)
            {
                /* 稳定了：更新 stable，并产生 down 事件 */
                u16 oldStable = g_keyStable;
                g_keyStable = now;
                g_keyDown = (now & (oldStable ^ now)); // 只取按下沿
                key_same_cnt = 3; // 卡住，直到变化再清
            }
            else
            {
                g_keyDown = 0;
            }
        }
    }
}

/* ===================== 主程序：业务逻辑层（只改显存，不管扫描） ===================== */
void main(void)
{
    Nixie_State NS = Nixie_State_ScreenOff;
    u8 num_show = 0;

    /* 上电初始化 */
    BusWrite(LATCH_LED, 0xFF); // LED全灭（如果你的LED是低电平亮）
    SEG_Clear();
    SEG_Set2Dec(0, 0);         // 前两位显示00

    /* 开定时器：从这一刻开始显示自动稳定刷新 */
    Timer0_Init_0p5ms();

    while(1)
    {
        /* --- 按键事件（由中断产生 down） --- */
        if(Key_GetDown(1))
        {
            num_show = 0;
            NS = Nixie_State_Run;
        }
        if(Key_GetDown(2))
        {
            if(NS == Nixie_State_Run) NS = Nixie_State_Pause;
            else if(NS == Nixie_State_Pause) NS = Nixie_State_Run;
        }
        if(Key_GetDown(3))
        {
            NS = Nixie_State_ScreenOff;
        }

        /* --- 状态机输出（只写显存） --- */
        if(NS == Nixie_State_ScreenOff)
        {
            /* 关屏：显存全灭即可 */
            SEG_Clear();
        }
        else
        {
            /* 显示两位 */
            SEG_Set2Dec(0, num_show);
        }

        /* --- 100ms节拍驱动计数（Run才走） --- */
        if(g_tick100ms)
        {
            g_tick100ms = 0;

            if(NS == Nixie_State_Run)
            {
                num_show++;
                if(num_show >= 100) num_show = 0;
            }
        }
    }
}
```


# 主要功能

## 显存

# Q & A

### volatile \ static \ 变量
- 为什么变量前要加volatile？
	- **volatile 的核心作用**：禁止编译器的寄存器缓存优化，强制变量每次读写都直接操作内存（而非缓存到寄存器），确保获取最新值。
	- **变量需加 volatile 的原因**：以 g_seg_buf、g_scan_pos 为例，它们是数码管扫描核心变量，主循环负责写入显示数据，定时器中断每隔几毫秒读取变量刷新数码管；
	- 中断与主循环异步执行，编译器编译时看不到中断逻辑，会误以为变量 “不会被修改”，进而缓存到寄存器反复使用旧值；
	- 最终导致数码管显示乱跳、不更新，**加 volatile 可明确告知编译器：变量可能被中断、硬件等外部力量修改，必须每次从内存读取最新值，保障数据同步正确**。

- 为什么要加静态static？
	- 限制变量的**作用域在本.c文件中使用**

- 各大全局变量的作用：
	- **static volatile u8 g_seg_buf[DIGITS];**--断码
	    数码管显示缓冲区。
	    用来存放每个数码管要显示的 “段码”（比如 0、1、2… 对应的亮灭组合）。
	    主循环往这里写要显示的数字，定时器中断从这里读出来点亮数码管。
	    
	- **static volatile u8 g_scan_pos = 0;**--位码
	    数码管当前扫描位置。
	    表示现在正在点亮第几个数码管（第 0 位、第 1 位…）。
	    定时器中断里每次扫描一位，扫描完就 `g_scan_pos++`，循环切换。
	    
	- **static volatile u16 g_ms_cnt = 0;**
	    毫秒计数器。
	    定时器中断里每 1ms 加 1，用来做时间基准（比如计时、延时、定时任务）。
	    
	- **static volatile bit g_100ms_flag = 0;**
	    100ms 定时标志。
	    当 `g_ms_cnt` 累计到 100 时，置 1；主循环检测到为 1 就执行 100ms 一次的任务，执行完清 0。
	    
	- **static u8 g_led_state = 0x00;**
	    LED 状态寄存器。
	    每一位对应一个 LED 的亮灭（0 灭 / 1 亮），主循环或定时器里根据这个变量控制 LED 输出。


### 定时器相关

- 定时器的配置？
	- Timer0_Init_0p5ms配置解释
		- void Timer0_Init_0p5ms(void)
			{
			    AUXR &= ~0x80;
			    TMOD &= 0xF0;
			    TMOD |= 0x01;
			    TH0 = 0xEA;
			    TL0 = 0x56;
				ET0 = 1;
				EA  = 1;
			    TR0 = 1;
			}
		- **整体功能**：Timer0_Init_0p5ms 用于初始化定时器 0，配置为 0.5ms 中断一次，并开启总中断、定时器 0 中断，最后启动定时器。
		  
		- **AUXR &= ~0x80**：AUXR 为辅助寄存器，将第 7 位清 0，选择定时器时钟为 12T 模式（传统 8051 速度），12 个时钟周期为 1 个机器周期，11.0592MHz 晶振下机器周期约 1.085us。
			该操作能选择定时器时钟的原因：
			- AUXR 寄存器的第 7 位（通常称为 T0x12 或类似名称）是专门用于配置定时器 0 时钟分频模式的控制位，由芯片硬件定义，软件通过写该位即可切换分频模式。
			- 硬件规定：**该位为 0 时，选择 12T 模式（12 个时钟周期 = 1 个机器周期）；为 1 时，选择 1T 模式（1 个时钟周期 = 1 个机器周期）。**
			- `AUXR &= ~0x80` 等价于 `AUXR.7 = 0`，因此硬件会按定义切换到 12T 模式，这是芯片手册规定的固定映射关系，并非软件随意定义。
			  
		- **TMOD &= 0xF0**：TMOD 是定时器模式寄存器，高 4 位对应 T1、低 4 位对应 T0，该操作将 T0 的低 4 位清 0，不影响 T1。
		  
		- **TMOD |= 0x01**：将定时器 0 设置为模式 1（16 位定时器 / 计数器），由 TH0、TL0 组成 16 位计数器，最大计 65536 个机器周期。
		  
		- **TH0 = 0xEA; TL0 = 0x56**：设置定时器初值，决定中断周期，TH0 为高 8 位初值，TL0 为低 8 位初值。
			初值详细计算步骤（以 11.0592MHz、12T 模式、目标 0.5ms 中断为例）：
			1. 计算机器周期：机器周期 = 12 ÷ 晶振频率 = 12 ÷ 11059200 ≈1.085μs。
			2. 计算所需机器周期数：所需周期数 = 目标中断时间 ÷ 机器周期 = 0.5ms ÷ 1.085μs ≈ 461 个周期。
			3. 计算定时器初值：16 位定时器最大计数值为 65536，初值 = 65536 − 所需周期数 = 65536 − 461 = 65075。
			4. 转换为十六进制：65075 转十六进制为 0xFE53，高 8 位为 0xFE（TH0），低 8 位为 0x53（TL0）。
			5. 写入寄存器：将高 8 位写入 TH0，低 8 位写入 TL0，完成初值配置。
			   
		- **ET0 = 1**：ET0 是 Timer0 中断允许位，置 1 后允许定时器 0 产生中断。
		  
		- **EA = 1**：EA 是全局中断允许位（总开关），置 1 后打开总中断，使能所有中断响应。
		  
		- **TR0 = 1**：TR0 是 Timer0 运行控制位，置 1 后启动定时器 0 开始计数。
		  
		- **整体流程**：配置定时器 0 为 16 位模式，设置初值实现 0.5ms 溢出中断，开启定时器 0 中断与总中断，启动定时器；之后每 0.5ms 进入 Timer0_ISR 中断服务函数，可用于数码管扫描、毫秒计时、按键扫描、定时任务等。

- void Timer0_ISR(void) 和 interrupt 1void Timer0_Init_0p5ms_11M0592_12T(void)这两函数有什么联系吗
	- **两个函数的关系**：`Timer0_Init...` 与 `Timer0_ISR` 如同 “闹钟设置” 与 “闹钟响后动作”，通过硬件中断机制紧密关联，前者负责配置，后者负责响应执行。
	- **核心关系：配置与执行**
	    
	    - `Timer0_Init...` 是 “因”（设置）：配置定时器 0 为 0.5ms 中断一次，开启相关中断并启动定时器，相当于设定闹钟时间并打开开关。
	    - `Timer0_ISR` 是 “果”（响应）：0.5ms 时间到后，硬件自动触发中断，暂停主程序执行该函数，相当于闹钟响后执行起床等动作。
	- **两者的 “握手” 关键**
	    
	    - 中断向量号：`Timer0_ISR` 后的 `interrupt 1` 是 8051 单片机标准写法，数字 1 代表定时器 0 中断入口；`Init` 中设置 `ET0 = 1`（允许定时器 0 中断）和 `EA = 1`（开启总中断）后，硬件溢出时会自动执行该编号函数。
	    - 时间常数配合：`Init` 中装入 `TH0`、`TL0` 初值决定首次中断时间为 0.5ms；`ISR` 中必须重新装入该初值，否则定时器溢出后归零，下次中断时间变为满量程计数时间（约 70ms），导致数码管剧烈闪烁。
	- **逻辑流程**
	    
	    - 调用 `Timer0_Init...`：设定工作模式、装载初值，`TR0 = 1` 启动定时器开始计数。
	    - 等待 0.5ms：CPU 执行 `main` 函数中的任务。
	    - 溢出瞬间：硬件产生中断信号，强制 CPU 暂停当前任务。
	    - 自动跳入 `Timer0_ISR`：重装初值保证下次仍为 0.5ms 中断，执行数码管刷新、计数标志置位等操作。
	    - 退出 ISR：CPU 回到 `main` 函数中断处继续执行。
	- **现实类比**
	    - 初始化（`Timer0_Init...`）：把闹钟拨到 7:00 并打开开关。
	    - 等待（硬件计数）：执行主任务（如睡觉）。
	    - 触发（硬件中断）：闹钟准时响起。
	    - 响应（`Timer0_ISR`）：执行对应动作（如起床），并重新设置闹钟时间（重装初值）。

- void Timer0_ISR(void) interrupt 1 和void Timer0Server() interrupt 1 有什么区别
	- `interrupt 1` 表示：**这个函数是“中断向量号 1”的中断服务函数**。
	-  1) `void Timer0_ISR(void) interrupt 1`
	-  2) `void Timer0Server() interrupt 1`
	- 无本质区别
### 数码管显示相关

- 为什么数码管

### 