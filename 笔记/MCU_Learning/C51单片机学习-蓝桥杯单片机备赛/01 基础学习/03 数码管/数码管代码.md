# 1. 数码管显示基础

## 一位数码管显示
### 一位数码管静态显示

- 基本显示方式
```c
    // 1. 告诉硬件：我要选左起第 1 个数码管
    // 0x01 (0000 0001) 代表选中第 1 位
    BusWrite(LATCH_DIG, 0x01); 

    // 2. 告诉硬件：在这个位置显示数字 "8"
    // 0x80 是数字 "8" 的段码（除了 dp 位，其余 a-g 全亮）
    BusWrite(LATCH_SEG, 0x80); 
```

- 封装成函数
	- 使用 **· 消位 - 消隐 - 选位 - 选段 ·** 的方式
	- **消位消隐**即   灭掉所有数码位以及段码
	- **选位选段**即   亮所需要的段码和数码管位
	- 注意：
		- 消位用0x00，点亮数码管的8位中是高电平1有效，0x00为全灭
		- 消隐就要看共阳还是共阴极
			- 共阳极接电源Vcc，低电平1有效
			- 共阴极接地GND，高电平1有效
	- 封装**段码表**对应数字
		- `static const u8 SEG_TAB[10] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90};`（如果想加上字母可后续补充）
		- 这里是共阳极，低电平有效，
		- 0000 0000表示全亮（包括小数点，小数点为最左位）
```c
void SEG_Show_1Digit(u8 pos, u8 num)
{
    if(num > 9) num = 0;
	BusWrite(LATCH_DIG, 0x00);                 // 消位
    BusWrite(LATCH_SEG, 0xFF);                 // 消隐
    BusWrite(LATCH_DIG, (u8)(0x01 << pos));    // 选位
    BusWrite(LATCH_SEG, SEG_TAB[num]);         // 出段码
}
```

### 一位数码管动态显示

- 实现动态显示其实就是连续的静态显示的陈列
- 需要用到延时函数Delay（为什么要用延时而不直接循序写显示代码？---）
	- 每次显示实为赋给数码管两个重要的数据，位码和段码，执行完之后变量仍然会保持原来值，即**位码段码仍保留之前的赋值**
	- 再次调用显示代码则会**覆盖**上次的赋值，又由于每行代码执行时间极快，导致上次不显示；
	- 用Delay可以**持续延迟显示**数码管再继续显示
```c
SEG_Show_1Digit(pos, sep);
pos++, sep++;//若想在当前位循环显示，**pos不需要++**
if (pos > 7)
	pos = 0;
if (sep > 7)
	sep = 0;
Delay_ms(900);
```


## 多位数码管显示

### 多位数码管静态显示

- 封装成函数显示多位
	- 利用延迟delay连续刷新
	- 缺点：函数会占用更多资源，不利于程序运行
```c
void SEG_Show_Digit_2_Static(u8 pos, u8 num)
{
    u8 tens = num / 10 % 10;
    u8 ones = num % 10;
    SEG_Show_Digit(pos, tens);
    Delay_ms(1);
    SEG_Show_Digit(pos + 1, ones);
    Delay_ms(1);
}
```


### 多位数码管动态显示

- 未封装
```c
u16 t = 0, duration = 200;
    BusWrite(LATCH_LED, ~0x00);
    while(1)
    {
        for (num = 0; num < 99; num++)
        {
            tens = num / 10 % 10;
            units = num % 10;
            for (t = 0; t < duration; t ++)
            {
                SEG_Static_Show(0, tens);
                Delay_ms(2);
                SEG_Static_Show(1, units);
                Delay_ms(2);
            }
        }
    }
```

- 封装成函数
```c
void SEG_DurationShow_2Digit(u8 pos, u8 num, u8 duration_ms)
{
    u16 t = 0;
    if(num > 99)
        num = 0;
    for (t = 0; t < duration_ms; t ++)
    {
        SEG_StaticShow_2Digit(pos, num);
    }
}
```

# 2. 数码管显示进阶

## 1. 加显存和ScanOnce循环扫描

### 总体思路
- **显存 `DispBuf[]`**：存“每一位要显示的段码”（比如显示 0/1/2… 对应 `SEG_TAB[]`）。
- **刷新函数 `SEG_ScanOnce()`**：每次只点亮 **1 位**，从 `DispBuf[ScanPos]` 取段码输出，并让 `ScanPos` 自增循环。
- **主循环**：
    - 高频：不停调用 `SEG_ScanOnce()` + `Delay_ms(1)` 来刷新（避免闪烁）
    - 低频：每隔约 1s 改一次显存内容（改变要显示的数字）

### 写显存（写显示内容，但不直接点亮）
- 把某一位改成显示数字（而不是直接“点亮显示”）
- 显存里存的是段码（`SEG_TAB[num]`），扫描刷新时直接取出来用
```c
/* 写显存：把某一位改成显示数字 */
void SEG_SetDigit(u8 pos, u8 num)
{
    if(pos >= 8) return;
    if(num > 9) num = 0;
    DispBuf[pos] = SEG_TAB[num];//核心就是赋值给显存数组
}
```

### 数显函数（扫描刷新显示）
- **扫描一次 = 只刷新 1 位**
    - `DIG_TAB[ScanPos]`：决定“选通哪一位”（位码）
    - `DispBuf[ScanPos]`：决定“这一位亮哪些段”（段码）
- `ScanPos++` 并循环回 0：就能依次扫描 0~7 位
- **注意：**
    - ✅ 需要扫描 **8 次** 才能让 8 位都各显示一次（完成一轮）
    - ✅ 外面通常也会跟一个短延时（例如 1ms）用来**保持这一位点亮的时间**（亮度/刷新频率）
    - ⚠️ “消隐”主要靠刷新函数内部的“关位/灭段”来做，delay 主要是“保持点亮”
```c
void SEG_ScanOnce(void)
{
    BusWrite(LATCH_SEG, 0xFF);            // 消隐
    BusWrite(LATCH_DIG, DIG_TAB[ScanPos]);// 选位
    BusWrite(LATCH_SEG, DispBuf[ScanPos]);// 出段码
    ScanPos++;
    if(ScanPos >= 8) ScanPos = 0;  //为了显示所有的数码管位      
}
```

- 刷新频率与亮度（为什么要 Delay_ms(1)）
	- 你现在的节奏是：**每次扫描 1 位后 delay 1ms**
	- 那么一轮 8 位大约耗时：`8 * 1ms = 8ms`
	- 这意味着整屏刷新频率约：`1 / 8ms ≈ 125Hz`
	    - 125Hz 一般不会明显闪烁
	- **亮度与 delay**：
	    - delay 大一点：每位点亮时间更长 → 更亮，但整屏刷新变慢（可能闪）
	    - delay 太小：刷新很快但每位占空比低 → 可能变暗

### 主函数（高频刷新 + 低频改显存）

- 高频部分：让显示“持续稳定存在”
- 低频部分：每隔 1 秒修改一次显存，让显示内容变化
```c
while(1)
{
/* 高频：刷新显示（必须一直跑） */
	SEG_ScanOnce();
	Delay_ms(1);

/* 低频：更新显存内容（决定显示什么） */
	tick_ms++;
	if(tick_ms > 1000)
	{
		tick_ms = 0;
		SEG_SetDigit(0, num_show / 10);
		SEG_SetDigit(1, num_show % 10);
		num_show++;
		if(num_show > 99)
			num_show = 0;
	}
}
```

### 常见问题与补充
- **为什么更新显存不用很频繁？**  
    因为真正“点亮”的是扫描刷新，高频刷新保证视觉连续；显存只决定“显示什么内容”，变化慢也没问题。
- **为什么会出现重影/鬼影？**  
    常见原因是切换位的时候段码还没清干净、位码没关干净，所以建议扫描函数里先“关位+灭段”，再“选位+出段码”。
- **为什么不要用 ScanPos 来决定写哪一位？**  
    因为 ScanPos 是“扫描过程变量”，一直在变。写显存要写固定位置（例如 0、1 位），否则数字会漂移。


## 2. 定时器0中断扫描数码管（1ms 扫描一次）

**目标**：把数码管动态扫描（`SEG_ScanOnce()`）交给 **定时器0中断**，每 **1ms** 执行一次；主循环只负责“更新显示内容”（写缓冲），避免主循环阻塞导致闪烁。
**核心思路**
- **中断里做刷新**：每 1ms 切换一位数码管（8位轮询），视觉上就是常亮
- **主函数里做显示数据更新**：只改 `Disp_Buf_TAB[]`，不直接去“扫”
- `G_ms` 作为毫秒计时基准，主循环用差值判断是否到时间（防止溢出问题）

### 定时器0初始化函数
- 需要加上 
	- ET0 = 1;//允许T0中断、
	- EA = 1;//中断总开关
```c
void Timer0Init(void)		//1毫秒@11.0592MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0xCD;		//设置定时初值
	TH0 = 0xD4;	   	//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
    ET0 = 1;//允许T0中断
    EA = 1;//中断总开关
}
```

### 中断服务函数
- **必须重装初值**：否则下次溢出周期会变
- **中断里只做“快任务”**：
    - 扫描一次 `SEG_ScanOnce()` ✅
    - `G_ms++` ✅
    - 不建议在中断里做复杂运算/长延时（会影响其他中断与显示稳定性）

> 小建议：`G_ms` 建议用 `volatile` 修饰，保证主循环读取到真实值（防止编译器优化）。

```c
void Time0_ISR(void) interrupt 1
{
    TL0 = 0xCD;		//设置定时初值
	TH0 = 0xD4;		//设置定时初值

    SEG_ScanOnce();
    G_ms += 1;//以后也可以在这里改变标志位变量的值，最后去主函数或者其他函数判断标志位是否改变
}
```


### 刷新和显示数码管

#### 1）写显示缓冲（主循环调用）
- `SEG_SetDigit(pos, num)` 只负责把“要显示的数字”转换为段码写入缓冲
- 真实点亮由 `SEG_ScanOnce()` 在中断里完成
```c
void SEG_SetDigit(u8 pos, u8 num)
{
    if(pos > 7)
        pos = 0;
    if(num > 9)
        num = 0;
    Disp_Buf_TAB[pos] = SEG_TAB[num];
}
```

#### 2）动态扫描一次（中断调用）

- 扫描流程常见写法：
    1. 先关闭所有位选（防鬼影）
    2. 段码输出成全灭或全亮做过渡（可选）
    3. 打开当前位选
    4. 输出当前位段码
    5. `ScanPos++` 循环
```c
void SEG_ScanOnce(void)
{
    BusWrite(LATCH_DIG, 0x00);                 //关闭所有位选(防止重影)
    BusWrite(LATCH_SEG, 0xFF);                 //段码清空/全灭(按硬件决定)
    BusWrite(LATCH_DIG, DIG_TAB[ScanPos]);     //选择当前位
    BusWrite(LATCH_SEG, Disp_Buf_TAB[ScanPos]);//输出当前位段码

    ScanPos++;
    if(ScanPos > 7)
        ScanPos = 0;
}
```



### 主函数

- 主循环每 **1000ms** 更新一次显示内容和 LED
- 使用 `(u16)(G_ms - Last_ms) >= 1000` 的写法：
    - 能正确处理 `G_ms` 溢出回绕（只要类型匹配合理）
- 主循环只调用 `SEG_SetDigit()` 写缓冲，不参与扫描
> 小建议：`G_ms` 最好定义为 `volatile u16` 或 `volatile u32`（视你工程需求），`Last_ms` 类型要与它匹配。
```c
void main()
{
    u16 Last_ms = 0;
    u8 Num_Show = 0;
    u8 FiveIn = 0;
    u8 FiveOut = 0;
    u8 LED_Bit = 0;
    BusWrite(LATCH_LED, 0xFF);
    Timer0Init();
    while(1)
    {
        if((u16)(G_ms - Last_ms) >= 1000)
        {
            Last_ms = G_ms;
            FiveIn = (Num_Show % 10 % 5);
            if(FiveIn == 0)
                FiveIn = 5;
            FiveOut = ((Num_Show + 9) % 10 / 5);
            LED_Bit = (0x01 << (FiveIn - 1)) | (0x01 << (FiveOut + 6));
            SEG_SetDigit(0, Num_Show / 10);
            SEG_SetDigit(1, Num_Show % 10);
            LED_Bit_Set(LED_Bit);
            Num_Show++;
            if(Num_Show > 99)
                Num_Show = 0;
        }
    }
}
```

### 注意点
- **变量声明建议（很重要）**
    - `G_ms`、`ScanPos`、`Disp_Buf_TAB[]` 这种在中断里会改/会读的变量，建议：
        - `volatile` 修饰（防优化）
        - 多字节变量（如 `u16/u32`）在 8051 上读写可能非原子：
            - 你现在的读法通常问题不大，但如果后续出现偶发跳变，可考虑在读取 `G_ms` 时临时关中断（`EA=0` / `EA=1`）做保护。
- **数码管闪烁/重影排查**
    - 中断周期不稳定（中断里任务太重）
    - `BusWrite()` 太慢，导致扫描占用过久
    - 位选与段选锁存顺序不对（不同硬件可能要先段后位/先位后段）
- **刷新频率概念**
    - 1ms 扫 1 位，8 位一轮 = 8ms 一帧
    - 帧率约 125Hz，人眼很稳（一般 > 60Hz 就基本不闪）